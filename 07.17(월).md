# 오늘 공부한 내용
<pre>
  오류체크 하는 방법
  Join을 사용하는 쿼리문 짜는법
</pre>
# @ExceptionHandler
<pre>
  스프링 프레임워크에서 사용되는 어노테이션으로, 예외 처리를 담당하는 메서드를 지정할 때 사용됩니다. 
  스프링에서 웹 애플리케이션을 개발할 때, 사용자의 요청을 처리하는 컨트롤러(Controller)에서 예외가 발생할 수 있습니다. 
  이러한 예외를 처리하기 위해 @ExceptionHandler 어노테이션을 사용합니다.
</pre>
# 예시
<pre>
  
*AdminRestController
@GetMapping("/api/admin/users")
	public ResponseEntity<?> allUserList() {
		List<UserListDto> userList;
		try {
			userList = service.getUsersList();
		} catch (Exception e) {
			throw new CustomApiException("사용자 조회 실패");
		}
		return new ResponseEntity<>(new CMRespDto<>(1, "사용자 목록 조회 성공", userList), HttpStatus.OK);
	}
  
*ControllerExceptionHandler.java
package com.example.platform.global.handler.error;
//import문은 제거를 했습니다.
@RestController
@ControllerAdvice
public class ControllerExceptionHandler<T> {
	// 예시 RuntimeException 이 발동하는 에러를 exampleException 함수가 가로챈다. 
	@ExceptionHandler(RuntimeException.class)
	public String exampleException(RuntimeException e) {
		return e.getMessage();
	}
	@ExceptionHandler(CustomApiException.class)
	public ResponseEntity<?> apiException(CustomApiException e) {
		return new ResponseEntity<>(new CMRespDto<>(-1,e.getMessage(),null),HttpStatus.BAD_REQUEST);
	}
	@ExceptionHandler(CustomValidationException.class)
	public ResponseEntity<?> validationException(CustomValidationException e){
		return new ResponseEntity<>(new CMRespDto<>(-1,e.getMessage(),null),HttpStatus.BAD_REQUEST);	
	}
	@ExceptionHandler(CustomJwtException.class)
	public ResponseEntity<?> jwtException(CustomJwtException e){
		return new ResponseEntity<>(new CMRespDto<>(-11,e.getMessage(),12),HttpStatus.BAD_REQUEST);	
	}
	@ExceptionHandler(CustomFileException.class)
	public String fileException(CustomFileException e){
		return e.getMessage();	
	}
}
      
*CustromApiException.java (CustomFileException, CustomJwtException과 동일)
package com.example.platform.global.handler.error.ex;
public class CustomApiException extends RuntimeException {
	private static final long serialVersionUID = 1L; //   직렬화(Serialization)에 사용되는 버전 번호(serialVersionUID)를 명시적으로 지정한 것
  public CustomApiException (String message) {          버전 번호를 지정하는 것은 객체의 직렬화와 역직렬화 과정에서 클래스 구조가 변경되었을 때 버전 충돌을 방지하기 위해서입니다. 
     super(message);                                    예를 들어, 클래스의 구조를 변경하면 기존에 직렬화된 객체를 역직렬화할 때 에러가 발생할 수 있으나, 
	}                                                               serialVersionUID를 명시적으로 설정하면 버전 번호를 일치시킬 수 있어 문제를 방지할 수 있습니다.
}
      
*CustomValidationException.java
package com.example.platform.global.handler.error.ex;
import java.util.Map;
public class CustomValidationException extends RuntimeException {
	private static final long serialVersionUID = 1L;
	private Map<String, String> errorMap;
	public CustomValidationException(String message) {
		super(message);
	}
	public CustomValidationException(String message, Map<String, String> errorMap) {
		super(message);
		this.errorMap = errorMap;
	}
	public Map<String, String> getErrorMap() {
		return errorMap;
	}
}
</pre>
# 설명
<pre>
일단 AdminRestController에서 로직이 실행되다가 오류가 나서 catch에 잡히면 'throw new CustomApiException("사용자 조회 실패");' 가 실행되면서 CustomApiException로 넘어가게 됩니다.
근데 넘어가는 중에 '@ExceptionHandler(CustomValidationException.class)' 이런게 있는지 체크를 하고 있다면 @ExceptionHandler쪽이 실행되고 없다면 사용자가 커스텀한 CustomApiException로 넘어갑니다.
제가 예시로 적어 놓은 코드는 '@ExceptionHandler(CustomValidationException.class)' 이 부분이 있기 때문에 CustomApiException.java로 이동하는 중간에 'throw new CustomApiException("사용자 조회 실패");'
이 코드를 가로채서 가져갑니다. 
최종적으로 과정을 정리했습니다.
</pre>
![image](https://github.com/SeungGwan123/SpringBoot/assets/123438749/1258b2f1-364a-42f3-a5fe-e365079513d9)
